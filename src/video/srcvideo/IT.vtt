WEBVTT

1
00:00:06.290 --> 00:00:15.850
大家好，我是温铭，很高兴有机会能够在这个大会上和大家分享关于 Apache APISIX 和云原生它们之间的一些话题。

2
00:00:16.210 --> 00:00:21.380
今天呢我分享的话题呢是基于 Apache APISIX 的全流量 API 网关。

3
00:00:22.440 --> 00:00:34.080
APISIX 呢它是一个从去年十月份进入 Apache 孵化器的一个开源项目，然后呢在今年七月份的时候我们就从 Apache 毕业，成为一个顶级项目。

4
00:00:34.280 --> 00:00:51.600
APISIX 它是专注在云原生网络层的一个 API 网关，我们希望呢不仅可以去做 API 网关，也可以去用 APISIX 去实现整个云原生的四层和七层的这种 API 和微服务的流量的分析和处理。

5
00:00:51.740 --> 00:01:03.260
所以我们不仅会做 API 网关，APISIX 呢也会去尝试去做类似于服务网格，K8S Ingress Controller 等等这样一些的开源项目和解决的方案。

6
00:01:04.820 --> 00:01:21.170
然后在开始之前呢我先做一个自我介绍，我是温铭，是深圳支流科技的联合创始人和 CEO，呃我也是 Apache APISIX 这个项目的项目的 VP，也是 Apache 软件基金会的呃 VP，对。

7
00:01:21.820 --> 00:01:27.990
呃同时呢除了<fluency>贡献</fluency>给 APISIX 这个项目贡献代码之外呢，我也是 SkyWalking 的 committer。

8
00:01:29.110 --> 00:01:34.930
在去年的时候呢，呃我在极客时间写了一个《OpenResty 从入门到实战》的专栏。

9
00:01:35.480 --> 00:01:44.650
在开始创业之前呢我在360工作了很长时间，我是360开源委员会的发起人，对，所以我在安全方面有过这样一些专利。

10
00:01:47.020 --> 00:01:49.720
呃首先我来介绍一下我们公司的一个背景。

11
00:01:50.150 --> 00:01:59.930
APISIX 呢呃是一个开源的项目，我们会在开源项目的基础之上做一些商业化的产品和商业化的支持。

12
00:02:00.150 --> 00:02:02.230
然后这就是支流科技。

13
00:02:03.060 --> 00:02:17.360
支流科技呢是<fluency>唯一一个</fluency>中国唯一一个由创业公司捐献给 Apache 的这样的一家呃公司，其它的呢都是一些大厂把开源项目捐给 Apache，只有支流科技是一个很小的创业公司。

14
00:02:18.000 --> 00:02:25.640
同时除了 Apache 基金会之外呢，我们也是 Linux 软件基金会的银牌会员，也是微服务 TARS 基金会的创始会员。

15
00:02:27.680 --> 00:02:29.530
今天呢我会大概聊几个话题。

16
00:02:29.660 --> 00:02:33.270
第一个是呢云原生给我们带来的一个机遇。

17
00:02:33.630 --> 00:02:39.510
我们今天的这个大会的主题也是云原生，很多的话题都是和云原生相关的。

18
00:02:39.580 --> 00:02:51.740
如果没有云原生，那么其实现在的网关，数据库，消息中间件，包括我们服务的编排等等之类的，都不会有这么大的一个新的机遇和挑战。

19
00:02:52.340 --> 00:02:57.290
然后后面呢我们会说一下云原生给微服务和网关带来了哪些新的变化。

20
00:02:57.990 --> 00:03:07.430
然后呢是 APISIX 的一个简单的介绍，什么是 APISIX？它可以帮大家处理什么样的问题？APISIX 和其它的网关相比，它有哪些技术的优势？

21
00:03:07.830 --> 00:03:14.840
然后最后一个部分呢<fluency>就是</fluency>也是今天的重点，就是我们希望 APISIX 去处理一个全流量的。

22
00:03:15.210 --> 00:03:30.420
这里的全流量指的是呢不仅是处理南北向的流量，从客户端到服务端我们称为是南北向的流量，<fluency>从在用户的</fluency>服务端它的服务之间的互相调用呢我们叫做横向的，东西向的流量。

23
00:03:30.820 --> 00:03:39.080
我们需要 APISIX 是可以处理从客户端到服务端的南北向，也可以处理服务之间东西向，做一个全流量的 API 网关。

24
00:03:39.340 --> 00:03:42.600
最后呢是我们开源项目的一些规划。

25
00:03:45.130 --> 00:03:47.920
首先我们看一下云原生的这个很大的一个背景。

26
00:03:48.970 --> 00:03:53.000
云原生里面呢有几个很重要的点，第一个呢就是容器。

27
00:03:53.810 --> 00:04:03.490
在云原生里面呢我们会把我们之前跑在物理机<fluency>跑在容器</fluency>上面的这些服务改改了一个方式，我们把它跑在容器上面。

28
00:04:03.700 --> 00:04:11.920
这样的话呢它带来几个好处，第一个好处是我可以用非常快的速度新起一个服务或者关闭一个服务。

29
00:04:12.340 --> 00:04:22.060
我在一个物理机上可以起几十个，几百个不同的服务起来，这是之前虚拟虚拟机时代所达不到的这样一个方式。

30
00:04:22.330 --> 00:04:31.460
第二个方式呢，我使用容器的这种方式之后，我可以把我的服务拆得比较小，所以说呢容器和微服务是相生相伴。

31
00:04:33.460 --> 00:04:35.000
然后我们再来看一下微服务。

32
00:04:35.500 --> 00:04:43.540
微服务呢顾名思义，它是把之前的单体的应用拆成了很多小的一些服务，把它变小了。

33
00:04:43.850 --> 00:04:57.540
我们举一个例子，以前如果我们去购物，从用户的登录到他商品的浏览，到他的下单，支付，然后等等整个流程，它都是在一个单体的架构里面。

34
00:04:58.290 --> 00:05:05.040
然后每一个业务，不同的业务，它是通过 SDK 的这种方式来做这种调用。

35
00:05:05.450 --> 00:05:23.680
但是现在我们在微服务里面，我们就可以改成每一个服务都是在一个单独的容器里面部署，然后它们之间通过 HTTP 或者 RPC 进行一个调用，这样的好处是我其中某一个服务宕掉了，我不会影响到其它的服务，因为它们完全不在一个容器里面。

36
00:05:24.580 --> 00:05:30.180
还有一个好处就是如果我的流量高峰来了，我可以很快地扩容。

37
00:05:30.300 --> 00:05:46.520
比如说我的下单，这个呢我可以把我服务器扩得很大，然后呢但是我的登录我的登录服务依然可以保持比较小的这种资源的占用，我们可以极大地去节约我们的机器和网络的这个成本。

38
00:05:47.520 --> 00:05:48.780
还有一个就是 K8S。

39
00:05:49.550 --> 00:06:04.450
K8S 呢很多人说它是云原生里面的操作系统，这个呢就等于说我们会用 K8S 把我们所有的服务进行一个编排，统一地给管理起来，没有 K8S 我们就没有办法去很好地去管理容器。

40
00:06:04.880 --> 00:06:22.080
这几个呢就是云原生里面的一些基础的概念，它们正在把之前我们传统的虚拟机，物理机，单体服务等等这些东西给颠覆掉，所以在云原生里面我们会面临非常多的新的挑战，当然也会带来非常多的新的机会。

41
00:06:22.640 --> 00:06:29.740
在最后呢对于企业用户来说，我们最终看到的就是一个公有云，混合云的这样的一个架构。

42
00:06:29.990 --> 00:06:41.710
在这种架构的基础之上，我们会把自己的服务向云上去靠拢，最终我们的目标就是我们是一个<fluency>云</fluency>完完全全长在云上的这样的一个服务和应用。

43
00:06:43.840 --> 00:06:45.930
那么它能给我们带来什么样的一个机会？

44
00:06:46.940 --> 00:07:05.540
呃我们可以回想一下，在云原生时代之前比如说在五年前，十年前，我们很多的服务其实是闭源的，对吧？很多是闭源的一些组件，比如说 Oracle，IBM，还有 EMC，IOE，它们很多是闭源的。

45
00:07:05.760 --> 00:07:16.310
但是在云原生时代，我们的数据库，我们的 API 网关，我们的消息中间件，这些东西都是开源项目去完成了。

46
00:07:17.180 --> 00:07:28.500
在云原生里面呢如果你这个项目不是开源的，那么你就很难去快速地去占领用户的心智，你就没有办法很快速地去<fluency>向台</fluency>向前迭代。

47
00:07:29.650 --> 00:07:42.210
然后呢另外一个机遇是说<fluency>在大的技术变迁里面</fluency>每隔一段时间我们都有一些大的技术变迁，云原生是其中的很重要的一个，这其实是对于企业来说是一个弯道超车的一个机会。

48
00:07:42.220 --> 00:07:53.550
比如说招商银行每年会投入收入的3.5%用于金融科技，它就可以在基础的架构给用户的体验上拉开了一个很大的一个距离。

49
00:07:54.250 --> 00:07:59.260
那么<fluency>微</fluency>API 网关呢，为什么我们觉得它是一个比较好的一个机会呢？

50
00:07:59.300 --> 00:08:14.040
<fluency>因为</fluency>我们可以看一下 API 网关它的作用是什么？API 网关是企业流量的入口，所有业务流量的入口，它不处理图片，视频等等这些 CDN 的这些流量，这些流量很大，但是不是 API 网关关心的。

51
00:08:14.180 --> 00:08:27.720
API 网关关心的是什么呢？它关心的是用户的支付，登录，浏览等等这些很核心的一些东西，而这些东西是能够直接带来生产力的提升。

52
00:08:27.850 --> 00:08:45.170
对开发来说是生产力的提升，对用户来说呢是它的一个用户体验的提升，或者是它的一个<fluency>呃现金的这种转换</fluency>订单的转换率，所以从 API 入手对于企业来说是一个事半功倍的一个方法。

53
00:08:47.030 --> 00:08:50.050
我们再来看一下 API 网关的传统功能有哪些？

54
00:08:50.800 --> 00:08:59.020
在介绍 APISIX 之前呢我们先来看一下，在 APISIX 诞生之前也有很多的 API，它们在做些什么事儿？

55
00:08:59.400 --> 00:09:16.770
比如说像 Nginx，Nginx 就是传统的反向代理，负载均衡，SSL 的卸载，对吧？然后上游的健康检查，可以说 Nginx 是引领了一个{\c&H0000FF&}webstore{\c&HFFFFFF&}的时代，但是在云原生里面呢它已经落伍了，为什么这么说呢？

56
00:09:17.260 --> 00:09:25.380
在云原生里面我们<fluency>很多的</fluency>很重要的一个点就是我的资源在弹性地伸缩，我的服务在不停地变化。

57
00:09:25.710 --> 00:09:39.580
但是 Nginx 是一个静态的配页面驱动的一个服务器，我修改了上游，我修改了证书，我修改了路由都是需要 reload 服务的，这在云原生里面呢是一个很难去接受的一个点。

58
00:09:42.440 --> 00:09:49.320
那么在云原生下面除了传统的网关的功能之外，我们还有很多新的功能需要去做。

59
00:09:49.720 --> 00:10:04.650
如果我们使用<fluency>F</fluency>Nginx 这样的服务器，那么也就意味着我需要去写 C 模块，或者是需要等待原厂给我的升级，它呢就会降低你的开发的效率和对用户新产品的反馈的一个速度。

60
00:10:05.870 --> 00:10:14.380
云原生下面呢可观测性是其中非常重要的一个点，比如说我对接普罗米修斯，我对接 Zipkin，Skywalking 这种 APM 的这种组件。

61
00:10:15.290 --> 00:10:25.450
可观测是我们在管理大量的 API 和微服务里面的第一需求，<unrecognizable>第二个<fluency>需</fluency>很大的需求是协议的转换。

62
00:10:26.310 --> 00:10:41.100
我们知道对于客户端来说呢一般我们提供的都是七层的 HTTP，HTTPS 的服务，但是在微服务里面它可能是 gRPC，可能是 Dubbo，也可能是自定义的四层的 RPC 的协议。

63
00:10:41.490 --> 00:10:47.430
在这个时候，网关就要完成一个非常重要的一个呃职责就是协议的转换。

64
00:10:47.790 --> 00:10:58.020
我对于终端客户来看到的还是 HTTP 协议，但是我<fluency>对于内部的服务之间的调用</fluency>通过网关之后我去调用内部的服务可能是 RPC 的协议。

65
00:10:59.280 --> 00:11:18.980
还有一个就是身份认证，身份认证呢一般来说我们会提供<fluency>一些</fluency>基础的一些身份认证的方式，比如说 King Author<tpe>key-auth</tpe>或者是 GWT，同样我们也可以去对接一些第三方 SaaS 的<fluency>云</fluency>身份云厂商，比如说Auth0之类的这样的云云厂商去做身份的认证。

66
00:11:20.210 --> 00:11:28.400
最终我们希望它能够达到一个动态，高性能，随意扩充，无状态的一个 API 网关，对。

67
00:11:30.470 --> 00:11:34.370
然后<fluency>我们再来看一下</fluency>从商业的角度我们来看一下 API 网关这个领域。

68
00:11:34.770 --> 00:11:40.910
呃这个是 Gartner 的一个分析报告，我们可以看到 API 网关是一个十几亿美元的一个市场。

69
00:11:41.790 --> 00:11:55.740
这在和数据库啊或者是和容器市场来相比，它并不是一个很大的市场，但是我们可以看到在它的 leader 的这个象限里面都是巨头，像谷歌，IBM，Salesforce。

70
00:11:56.910 --> 00:12:02.470
为什么它们会去做一个市场看上去没有那么大的一个 API 的这个东西呢？

71
00:12:03.280 --> 00:12:20.000
其实理由很简单，因为大家都希望拿到流量的入口，特别是业务流量的入口，然后我可以很方便地扩展到 API 的全生命周期，API 的安全，然后数据的分析和处理，

72
00:12:20.720 --> 00:12:24.810
这就是变成了<fluency>一个</fluency>很大的一个产品的一个范围。

73
00:12:26.840 --> 00:12:30.370
嗯这里是一些和 API 网关相关的一些收购。

74
00:12:32.410 --> 00:12:45.200
总体来说我们可以看到在 API 网关领域大家是从闭源走向了开源，从私有云走向了混合云这样一个架构，这个不只是 API 网关，在云原生同样也是这样的一个方式。

75
00:12:46.440 --> 00:12:49.620
然后我们<fluency>再来看一下</fluency>进入今天的主题，APISIX 是什么？

76
00:12:50.600 --> 00:12:54.350
用一句话来介绍呢，APISIX 是一个云原生的 API 网关。

77
00:12:54.620 --> 00:13:08.330
APISIX 是在2019年4月份的时候开始去写代码，然后在六月份的时候开源，所以它从自己基础架构的选型就是走的云原生的基础的路线。

78
00:13:08.560 --> 00:13:23.610
我们没有使用 Postgre<tpe>PostgreSQL</tpe>，MySQL 之类的关系型数据库去存储我们的配置，我们使用的是什么呢？使用的是 etcd，和 K8S 的选择是一样的，我们都使用 etcd 去做这样的我们<fluency>存储存</fluency>数据的存储和分发。

79
00:13:24.290 --> 00:13:38.360
然后呢 APISIX 发展得非常得快，我们从去年六月份开始是每个月发一个版本，然后我们现在已经发了十几个版本，每个月一个版本的向前迭代，它也是中国最快速度毕业的 Apache 的顶级项目。

80
00:13:40.080 --> 00:13:43.690
APISIX 如果<fluency>有</fluency>只有一个特点的话，那那么这个特点一定是动态。

81
00:13:44.450 --> 00:13:51.870
在 APISIX 里我们的路由，我们的证书，我们的上游，包括我们插件的本身都是动态的。

82
00:13:52.730 --> 00:14:02.000
动态的意思是说我不用重新加载服务，我可以通过 API 的方式去去任意地去修改所有的配置。

83
00:14:03.320 --> 00:14:21.410
然后现在 APISIX 已经有了四十多个插件，也就是说你可以用 APISIX 去处理身份认证，安全，限流限速，APM，呃还有我们的可观测性等等，都可以通过网关来把这些公共的功能在网关层面实实现。

84
00:14:23.540 --> 00:14:26.500
我们来看一下 APISIX 的设计的一些思路。

85
00:14:26.530 --> 00:14:30.180
首先呢 APISIX 是数据平面和控制平面分离的。

86
00:14:30.750 --> 00:14:32.720
这个是什么意思呢？我们来看一下这个图。

87
00:14:33.700 --> 00:14:49.200
在左侧是 APISIX 的 Data Plane，也就是它的数据平面，在右侧呢是 APISIX 的 Control Plane，也就是它的控制平面，它们之间呢只有通过了 etcd 作为一个中转的连接。

88
00:14:50.440 --> 00:15:09.120
我们可以看一下，呃客户端的请求首先从客户端的浏览器或者是它的手机 APP，甚至是它的一些物联网设备到了 APISIX 网关这个层面，在网关中呢我们会有四十多个插件给用户去选择，去做一个处理。

89
00:15:10.010 --> 00:15:18.680
最终我们会把这些呃客户端的请求发给我们的合作伙伴，我们自己的 API 或者是调其它 SaaS 类的服务的一些 API。

90
00:15:19.640 --> 00:15:20.970
这是数据平面做的事情。

91
00:15:21.300 --> 00:15:28.180
那么控制平面呢更多的是去配置，我告诉数据平面要怎么样去处理和分发这些流量。

92
00:15:29.680 --> 00:15:37.050
控制平面比较简单，就是<fluency>通过</fluency>管理员通过一个 RESTful 的 API 把这些指令写到 etcd。

93
00:15:37.800 --> 00:15:51.000
然后数据平面会 watch etcd 的变更，在毫秒级别，一般是一毫秒两毫秒这个级别，我就可以<fluency>把控制源</fluency>把管理员的控制指令同步到我们所有的数据平面中去。

94
00:15:51.950 --> 00:16:09.460
然后数据平面呢也会定期地把自己的一些 tracing，metrics，logging 这样的一些日志喂给我们<fluency>是</fluency>第三方的组件，比如说 Skywalking，还有普罗米修斯，然后<fluency>用</fluency>通过 grafana 来展示出，这就是 APISIX 整个组件。

95
00:16:09.770 --> 00:16:21.160
所以 APISIX 和其它的 API 网关相比它的架构是非常地清晰的，简单，可靠，高可用，这是 APISIX 的设计里面非常重要的几个理念。

96
00:16:23.110 --> 00:16:35.840
然后 API 网关对于企业用户来说呢多多少少都可以进行二次的开发，因为我们有一些新旧系统的对接，有一些自己业务逻辑的一些特殊性，我们都需要进行下二次开发。

97
00:16:36.140 --> 00:16:51.320
在 APISIX 里面我们进行二次开发是通过插件的方式去实现的，也就是说我只用实现自己业务逻辑，<fluency>的</fluency>像搭积木一样地放在 APISIX 这个上面就 OK 了，我不用去改 APISIX 核心的一些东西。

98
00:16:53.180 --> 00:16:58.600
然后下面是一些性能和运维友好的这样一些东西，比如说我们支持流量的复制。

99
00:16:58.960 --> 00:17:07.750
这个流量复制呢和 Nginx 流量复制不一样，是我们支持单条路由的而且是带条件的流量复制，会把这个粒度变得很细。

100
00:17:08.660 --> 00:17:20.630
还有一个是故障注入，我们可以模拟任意上游的呃 APP 的响应码和它的 response body，这样我们就可以很方便地去模拟各种异常情况。

101
00:17:23.060 --> 00:17:26.860
然后这是 APISIX 的一个整体的一个生态图。

102
00:17:27.460 --> 00:17:38.460
我们除了看到 APISIX 支持 HTTP，HTTPS，gRPC 之类的协议之外，我们也支持 MQTT 这样物联网的协议。

103
00:17:38.640 --> 00:17:48.610
我们也有一些用户把 APISIX 用在了<fluency>他们的呃</fluency>去 IoT 的这样一个环境下面去去收集他们设备的这样一些流量。

104
00:17:50.450 --> 00:17:55.940
从这个图我们其实可以看到 APISIX 和其它的网关有一些很大的不同。

105
00:17:56.700 --> 00:18:06.590
第一个不同我们先看一下，首先 APISIX 是基于 etcd 的，也就是我们的服务发现你可以放在 APISIX etcd 里面去完成，这是第一个。

106
00:18:06.970 --> 00:18:18.030
第二个呢是 APISIX 除了支持 etcd 之外，我们还支持 Consul，EUREKA，NACOS 等等各种不同的服务发现，服务注册的这样的 Web 的组件。

107
00:18:19.290 --> 00:18:22.900
我们不仅是支持，而且我们支持的粒度会比较地细。

108
00:18:22.930 --> 00:18:41.010
比如说我们有三个路由，第一个路由它的 server name 去 etcd 里面去查找，第二个路由我可以去 Consul 里面去查找，第三个我可以去 EUREKA 里面去查找，我不同的路由可以去配置不同的服务发现和服务注册中心去使用。

109
00:18:41.340 --> 00:18:56.540
这个是 APISIX 的第一个比较大的一个特色，就是我的服务注册中心能够挂载路由<unrecognizable>，这样的话呢我就可以去兼容用户很多呃异构的一些系统，去做一些统一的管理。

110
00:18:57.300 --> 00:19:06.720
第二个不同的是呢 APISIX 虽然有很多插件，但是这些插件之间是可以编排的，我们叫做插件编排。

111
00:19:07.250 --> 00:19:24.800
<fluency>我们可以把这四十多个插件的上下文</fluency>比如说 A 插件执行完了之后判断它的条件，然后再去执行 B 插件或者是 C 插件，这样子我们就通过这种插件编排的方式可以让用户随意地去生成新的插件。

112
00:19:25.300 --> 00:19:27.620
我们<fluency>只</fluency>把这个东西呢叫做插件编排。

113
00:19:27.900 --> 00:19:38.660
同样对应的，我们会把用户新生成的这个插件的代码自动生成出来，然后推给数据平面，这就是所谓的低代码的 API 网关。

114
00:19:38.800 --> 00:19:56.970
APISIX 呢是唯一一个开源的低代码 API 网关，它可以让产品经理，让 auth，让 security 等等不同的团队都有能力在 API 网关的这个层面上去编写插件，实现自己的逻辑，这是第二个很大的不同。

115
00:19:57.200 --> 00:20:00.360
第三个很大不同呢是 APISIX 会支持 AI Plane。

116
00:20:01.080 --> 00:20:07.990
我们可以刚才看到了我们有 DP，就是 Data Plane，我们也有控制平面 CP。

117
00:20:08.400 --> 00:20:13.730
一般的网关都是这控制面，数据面，但是 APISIX 有 AI 面。

118
00:20:14.060 --> 00:20:33.880
我们可以通过对日志和统计数据的学习，让网关知道正常的流量长什么样子，异常流量长什么样子，在发现异常流量的时候会自动地去做一些规则的处理，这样子的话我们就可以大大减轻我们运维的一个压力。

119
00:20:35.130 --> 00:20:38.600
这是 APISIX 很大的和其它网关不同的几个点之一。

120
00:20:40.540 --> 00:20:42.990
那么 APISIX 可可可以做什么事情呢？

121
00:20:43.650 --> 00:21:03.650
首先呢 APISIX 是可以处理四层和七层流量，比如说 HTTP，HTTPS，gRPC 等等之类，四层七层我们都是可以处理的，<fluency>是一个呃</fluency>基本上常见的协议都可以做，如果<fluency>这些</fluency>你自定义你自定义的一个协议APISIX 里面也可以做协议的转换，这是第一个。

122
00:21:04.140 --> 00:21:13.960
然后呢就是 APISIX 是一个全流量，就是我们今天讲的重点，它不仅可以替代 Nginx 去处理南北向的，也可以去处理东西向<unrecognizable>。

123
00:21:15.760 --> 00:21:20.270
同样的我们有一些用户把 APISIX 用在了 ingress controller 上。

124
00:21:22.020 --> 00:21:36.400
呃因为 APISIX 呢是一个偏基础的中间件，我们可以通过插件的方式去扩展 APISIX，把它转成不同的形态，比如说把 APISIX 变成了一 IoT 的网关，把 APISIX 变成了一个零信任的网关，

125
00:21:36.930 --> 00:21:43.240
这些都是有用户在他自己的场景上已经实现了这样的一些呃网关。

126
00:21:44.320 --> 00:21:46.960
然后再来提一下 APISIX 的技术的优势。

127
00:21:47.600 --> 00:21:53.720
这里大概列了六点，有列了六点，然后我就找呃找一个出来说一下。

128
00:21:54.060 --> 00:21:56.890
我们先来看一下，其实比较重要的是第一个。

129
00:21:57.500 --> 00:22:10.730
呃我们知道对于网关来说呢最重要的就是路由，什么是路由呢？大家用过 Nginx 就知道，我们在 Nginx 里面有一个 location，然后后面是个 uri 的地址，这个就叫做一条路由。

130
00:22:11.300 --> 00:22:18.430
那么在 APISIX 里面呢，虽然我们是基于 Nginx 来实现的，但是我们并没有使用 Nginx 的路由的方案。

131
00:22:19.220 --> 00:22:32.960
对，我们认为 Nginx 里面实现比较好的是它基础的网络库，而它的 IP 的匹配，路由的匹配，还有它的 C 模块的扩展，这些我们都没有使用，我们都是自己又重新做了一套。

132
00:22:34.370 --> 00:22:50.960
比如说在 APISIX 的路由复杂度是 OK<tpe>O(k)</tpe>，这个 k 呢指的是它的 uri 的一个长度，而不是它的数量，不是它的个数，比如说一万条路由和一百条路由，在 APISIX 里面呢它的时间复杂度是一样。

133
00:22:52.090 --> 00:22:56.780
对，所以不会随着路由条数的增长而对性能产生影响。

134
00:22:57.270 --> 00:23:05.810
但是其它的网关比如说 kong，它的时间复杂度是 ON<tpe>O(n)</tpe>，它会随着路由条数的增长而成一个线性的变化。

135
00:23:06.910 --> 00:23:10.240
嗯这些后面大家也可以去了解一下呢其它的。

136
00:23:11.170 --> 00:23:12.910
然后这里是插件编排。

137
00:23:13.580 --> 00:23:20.290
这里本来是有一个视频的，对，因为时间的关系我来大大概和大家说一下这个视频做什么事情。

138
00:23:21.240 --> 00:23:36.220
比如说 APISIX 里面有一些嗯插件，它可以去做一些安全的判断，比如说 IP 黑名单的一个插件，如果客户端的 IP 命中了 IP 黑名单的插件，我们就把它拦截掉，对吧？

139
00:23:36.300 --> 00:23:55.380
一般的网关都有这样的功能，但是如果你想实现<fluency>一个功能</fluency>一个新的功能，这个 IP 被拦截掉之后我不想直接拒绝它，我想把它引入一个蜜罐，然后呢如果没有被拒绝掉，我就<fluency>去</fluency>让它正常地去后面请求服务，只不过我多记一个日志。

140
00:23:56.180 --> 00:24:12.970
这是一个很正常的需求，但是在传统的网关你怎么办？你只有自己新写插件，写代码才能实现这样的逻辑，写完之后你要经过代码的测试，然后你要看它有没有性能的问题，会有一个很长的开发周期。

141
00:24:14.450 --> 00:24:33.200
但是在 APISIX 里面你只要两分钟的时间，你在 dashboard 的界面上拖拖拽拽就可以把这个刚才说的 IP 黑白名单，蜜罐<fluency>然后</fluency>这样的东西能够自动生成出来，而且它的代码已经被测试案例覆盖了，而且没有性能问题。

142
00:24:34.000 --> 00:24:36.920
这是一个很神奇的一个事情，就是低代码的网关。

143
00:24:37.080 --> 00:24:56.690
我们是怎么做的呢？我们是会把 APISIX 已有的插件进行一个上下文条件的判断，然后会组装它的运行顺序，它都是通过一个可视化的方式，你拖拖拽拽地把一个插件放在上面，下面指向哪一个插件来告诉它执行顺序。

144
00:24:57.130 --> 00:25:09.800
本质上呢它是一个有向无环图，也就是 DAG，我们会把这个 DAG 的有向无环图自动生成 Lua 代码，然后把它推给 etcd，然后在数据平面上把它给内存里面加载进来。

145
00:25:10.860 --> 00:25:14.330
对，感兴趣的大家可以去看一下 APISIX 的开源项目。

146
00:25:16.530 --> 00:25:20.230
我们把<unrecognizable>叫做从创意到创造。

147
00:25:21.010 --> 00:25:30.580
这个呢其实很多的网关都在尝试做类似的事情，比如说 Kong，它和 APISIX 是一样，它用 Lua 写 filter，写写 plugin，写插件。

148
00:25:31.060 --> 00:25:35.960
但是很多的开发觉得 Lua 不太好学，他不会，那么 Kong 就只是呢用 Golang 写。

149
00:25:37.080 --> 00:25:45.790
对 Envoy 也是一样的，使用C++写 filter 的成本比较高，那么它就 WebAssembly，我用 Lua 写也可以去扩展 Envoy。

150
00:25:46.190 --> 00:26:05.610
但是对于 APISIX 来说呢为什么我们一定要写代码？为什么不能让从产品经理，从安全人员的脑子里面他的一个构思，一个想法直接就是你的，对，为什么不能这么做呢？可以这么做，当然可以这么做。

151
00:26:07.040 --> 00:26:21.940
当然你要做到这个并不容易，你<fluency>需</fluency>首先需要实现的是你的微插件，你要把每一个插件剥离得很干净，然后这些插件的上下文还能够自动地去判断，然后把它代码自动生成出来，还是有一些技术难度。

152
00:26:23.840 --> 00:26:33.880
APISIX 现在有很多的开源的用户，也有一些付费的用户，这是我们列出来的一些呃正在使用 APISIX 的一些用户。

153
00:26:34.780 --> 00:26:36.830
呃这个是我们行业的细分。

154
00:26:37.680 --> 00:26:49.170
我们可以看到很多的行业，也有很多这种标杆的用户在使用 APISIX，这些用户都已经把 APISIX 放在它们的真正的生产环境上面去跑。

155
00:26:51.490 --> 00:26:55.320
这个是 APISIX 和 Kong 对比项，大家感兴趣的去可以看一下。

156
00:26:55.350 --> 00:26:59.980
其实我们和 Kong 最大的不一样一个是技术架构，第二个是性能上。

157
00:27:02.370 --> 00:27:04.600
然后我们看一下全流量 API 网关。

158
00:27:04.900 --> 00:27:11.180
Nginx 遇到了很大的挑战，特别是被F5收购了之后，它的商业化并不成功。

159
00:27:11.300 --> 00:27:25.280
然后在云原生里面呢，开源版本的 Nginx 没有办法做到动态，而闭源版在云原生的时代没有人会愿意去先尝试一个闭源的版本去解决它的问题，没有人希望被供应商锁定。

160
00:27:27.590 --> 00:27:30.430
那么<fluency>N</fluency>Nginx 就会有非常多的替代者，

161
00:27:30.800 --> 00:27:49.520
比如说呃 API 网关，Kong，APISIX 可以替代 Nginx，service proxy，Envoy，Traefik 可以去替代 Nginx，然后公有云的 CLB 加公有云的网关，或者公有云的 CLB 加公有云的 k8s 的 ingress controller 也可以替代 Nginx。

162
00:27:50.320 --> 00:27:59.270
那么东西向流量也是同样，它会随着云原生和微服务的兴起而变成了一个越来越大的这样一个流量，而且趋势越来越明显。

163
00:28:01.660 --> 00:28:08.400
在微服务里面 istio 和 Envoy 这种边车的话已经成为了一个 service mesh 的一个标准和主流。

164
00:28:10.520 --> 00:28:25.190
对于 Envoy，Kong，<fluency>A</fluency>Apache APISIX 来说它们最终的目标都是希望能够使呃处理所有的流量，没有人希望我只是一个 API 网关或者只是一个边车，大家都希望做的事情会更多。

165
00:28:27.200 --> 00:28:43.640
接入层呢不再是一些传统的F5和 Nginx 的市场，大家越来越多的开源项目都在向这块呢切入，比如说国内百度推出的 BFE，或者是蚂蚁金服推出的 MOSN，或者是阿里巴巴的 Tengine，它们都在做类似的这样一些事情。

166
00:28:45.000 --> 00:29:04.790
APISIX 呢是这么去考虑的，就是我们会以 Nginx 网络库为基础，因为 Nginx 足够地稳定，足够地高性能，它并没有被时代所淘汰，被时代所淘汰的是它使用静态配配置文件驱动这种方式，但是它底层的基础的东西还是呃写得非常棒。

167
00:29:06.150 --> 00:29:21.020
然后我们会增加独立的控制面，就是 CP，我们觉得 CP 是一个很重要的一个点，我们可以控制所有的 DP，不只是 APISIX，我们也可以去控控控制 Nginx，然后呢我们也会去增加 AI 的平面。

168
00:29:21.410 --> 00:29:35.560
AI 的平面呢，我们增加了这个之后就可以直接用数据去反哺业务，<fluency>而不只只是</fluency>而不仅仅是反向代理，负载均衡，我们去可以帮助用户解决更多业务层面上的问题，帮他们发现，帮他们解决问题。

169
00:29:36.280 --> 00:29:53.130
然后最终我们希望<fluency>整个过程整个过程</fluency>从网关到服务网格，到 CP，到 AI 层面，希望整个过程它都是一个低代码，低成本，让用户快速上手的这样的一个方法去实现。

170
00:29:54.420 --> 00:30:10.120
然后我们再来看一下 APISIX，APISIX 的开源呢其实<fluency>比较地</fluency>在外界看来都比较地顺利啊，像它是最快毕业的<unrecognizable>的项目，它也是被导师和孵化器主席认为是最省心的孵化器项目。

171
00:30:10.480 --> 00:30:20.180
对，其实其中的秘诀呢就是对社区的重视，每个月的一个版本，然后对社区快速地回复和响应，对贡献者的认可。

172
00:30:20.560 --> 00:30:33.630
但是呢背后其实也有很多大家看不到的或者是没有留意到，比如说每个月都有一个线下的 meetup，然后我们会频繁去走访我们的各种各样的用户，去知道用户到底需要一个什么样的产品。

173
00:30:35.610 --> 00:30:51.360
然后对于开源项目来说呢有很多的衡量指标，有人看 star 数，有人呢去看这个项目有多少家公司在用，也有人去看了它的 commit 数，它的 PR 的数量，对于 APISIX 来说呢我们只看活跃度。

174
00:30:52.440 --> 00:31:04.360
活跃度，什么是活跃度呢？就是我一个月之内有多少<fluency>贡</fluency>人贡献了代码？有多少 issue？有多少 PR？这个很重要，这些数据是没有办法造假。

175
00:31:05.110 --> 00:31:12.880
对，它代表着你有多少开发者在给你贡献代码，他贡献代码就是对你最高的一个认可。

176
00:31:13.300 --> 00:31:21.500
star 是最简单的，每个人随手一点就是一个 star，但是你只有真的很喜欢这个项目的时候才会给它贡献代码。

177
00:31:22.940 --> 00:31:36.220
APISIX 呢现在有近三十个 committer，然后其中有两个是欧洲的开发者，也有至少4位的大学生，所以我们希望把这个开发者的队伍能够变得非常多元化。

178
00:31:37.050 --> 00:31:44.440
然后我们有00后的 APISIX committer，这其实代表着我们希望有更多新鲜血液能够加入进来。

179
00:31:46.970 --> 00:31:50.890
然后大家看清里面很重要的一个点就是社区大于代码。

180
00:31:51.260 --> 00:32:00.010
以前呢我们觉得可能我们首先要好的代码才能吸引来大家用，但是我们现在觉得呢你要有一个好的社区才能吸引大家来。

181
00:32:00.840 --> 00:32:09.490
好的社区会帮你把不好的代码给改写成好的代码，但是一个社区没有发展起来，那么好的代码也会慢慢地死掉。

182
00:32:10.550 --> 00:32:29.190
生命力是一个社区最重要的一件事情，比如说 APISIX dashboard，大家其实觉得第一个版本不够好，很多用户在吐槽，那么怎么办呢？我们就找了五家公司一起讨论新 dashboard 应该怎么做？我们怎么把它变得更好？

183
00:32:31.130 --> 00:32:33.200
然后这是 APISIX 的一个规划。

184
00:32:33.280 --> 00:32:38.400
我们2.0版本是刚刚发布，我们使用了 etcd 的v3协议替代了v2协议。

185
00:32:38.650 --> 00:32:45.480
对，然后3.0版本呢我们会废弃掉 admin API，而把 CP 和 DP 完全地分离开。

186
00:32:47.300 --> 00:32:54.480
然后2021年，我们希望我们的活跃度能够进一步地提升，我们希望主项目的活跃度能够超过两百人。

187
00:32:55.150 --> 00:33:08.910
<fluency>在去年十月份的时候十</fluency>去年十月份，我们的贡献者只有20个人，然后呢我们现在呢有将近130个人，一年增长了100多，我们希望明年一样可以保持快速的增长。

188
00:33:09.780 --> 00:33:21.380
然后最终就是特别希望大家如果对今天的分享感兴趣，<fluency>想</fluency>希望知道 APISIX 的更多的细节，那么其实非常欢迎<fluency>给嗯</fluency>大家给 APISIX 做贡献。

189
00:33:21.690 --> 00:33:35.250
贡献呢不仅仅限于代码，像文档，意见的反馈，然后这些都是非常重要的贡献，它和代码之间的贡献是一样重要，对，所以非常希望大家给 APISIX 来做贡献。

190
00:33:35.930 --> 00:33:45.280
然后呢我们<fluency>会有一个QQ群我们QQ群呢</fluency>现在有两个 QQ 群，然后有两三千人在里面去交流 APISIX 的使用。

191
00:33:46.080 --> 00:33:57.380
对，非常欢迎大家<fluency>来到</fluency>加入 APISIX 的开源社区，和我们一起去构建一个世界顶级的一个开源项目，谢谢大家。

